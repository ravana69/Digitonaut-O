// Title: Organic Network
// Author: FAL
// Made with p5.js v0.5.16
// Generated by TypeScript v2.6.1
/* Log:
    24. Nov. 2017 : First version.
    25. Nov. 2017 : Refactoring, performance improving, graph layout improving
*/

"use strict";
//
// ------------ Common global Settings ------------------------------
//
/// <reference path="../../../../my_types/p5/p5.d.ts" />
p5.disableFriendlyErrors = true;
const IDEAL_FRAME_RATE = 60;
const UNIT_ANGLE_SPEED = 2 * Math.PI / IDEAL_FRAME_RATE;
const UNIT_SPEED = 1 / IDEAL_FRAME_RATE;
const UNIT_ACCELERATION_MAGNITUDE = UNIT_SPEED / IDEAL_FRAME_RATE;
const CANVAS_SHORT_SIDE_LENGTH = 640; // non-scaled size
let canvasScaleFactor;
let nonScaledWidth;
let nonScaledHeight;
let aspectRatio;
function updateCanvasScale() {
    canvasScaleFactor = Math.min(width, height) / CANVAS_SHORT_SIDE_LENGTH;
    nonScaledWidth = width / canvasScaleFactor;
    nonScaledHeight = height / canvasScaleFactor;
    aspectRatio = width / height;
}
//
// ---------- set on-demand global mode --------------------------------------------
// See also:
//   https://github.com/processing/p5.js/wiki/p5.js-overview#instantiation--namespace
//   https://github.com/processing/p5.js/wiki/Frequently-Asked-Questions
/// <reference path="../../../../my_types/p5/p5.d.ts" />
new p5();
//
// ------------ loopArray() -------------------------------------
//
function loopArray(array, callback) {
    for (let i = array.length - 1; i >= 0; i -= 1) {
        callback(array[i], i, array);
    }
}
//
// ------------ roundRobin() -------------------------------------
//
function roundRobin(array, callback) {
    const arrayLength = array.length;
    for (let i = 0, len = arrayLength - 1; i < len; i += 1) {
        for (let k = i + 1, kLen = arrayLength; k < kLen; k += 1) {
            callback(array[i], array[k]);
        }
    }
}
//
// ------------ nestedLoopJoin() -------------------------------------
//
function nestedLoopJoin(array, otherArray, callback) {
    for (let i = 0, len = array.length; i < len; i += 1) {
        for (let k = 0, kLen = otherArray.length; k < kLen; k += 1) {
            callback(array[i], otherArray[k]);
        }
    }
}
//
// ------------ Array wrapper -----------------------------
//
/// <reference path="functions/loopArray.ts" />
/// <reference path="functions/roundRobin.ts" />
/// <reference path="functions/nestedLoopJoin.ts" />
class ArrayWrapper {
    constructor() {
        this.array = [];
    }
    get length() {
        return this.array.length;
    }
    get(index) {
        return this.array[index];
    }
    getLast() {
        return this.array[this.array.length - 1];
    }
    push(element) {
        this.array.push(element);
    }
    pop() {
        return this.array.pop();
    }
    loop(callback) {
        loopArray(this.array, callback);
    }
    roundRobin(callback) {
        roundRobin(this.array, callback);
    }
    nestedLoopJoin(otherArray, callback) {
        nestedLoopJoin(this.array, otherArray.array, callback);
    }
}
//
// ------------ Steppable -----------------------------
//
/// <reference path="ArrayWrapper.ts" />
class SteppableArray extends ArrayWrapper {
    static stepFunction(value) {
        value.step();
    }
    step() {
        this.loop(SteppableArray.stepFunction);
    }
}
//
// ------------ Kinematic quantity -----------------------------
//
/// <reference path="../../../my_types/p5/p5.global-mode.d.ts" />
/// <reference path="Steppable.ts" />
class KinematicQuantity {
    constructor() {
        this.position = createVector();
        this.velocity = createVector();
    }
    step() {
        this.position.add(this.velocity);
    }
    getSpeed() {
        return this.velocity.mag();
    }
    getDirection() {
        return this.velocity.heading();
    }
    addSpeed(speedChange) {
        this.velocity.setMag(Math.max(0, this.velocity.mag() + speedChange));
    }
}
//
// ---------- distSq() --------------------------------------------
//
/// <reference path="../../../../my_types/p5/p5.global-mode.d.ts" />
/**
 * Calculates the squared value of the Euclidean distance between
 * two points (considering a point as a vector object).
 */
function distSq(v1, v2) {
    return sq(v2.x - v1.x) + sq(v2.y - v1.y) + sq(v2.z - v1.z);
}
//
// ------------ Physics body -----------------------------
//
/// <reference path="global/onDemandGlobalMode.ts" />
/// <reference path="KinematicQuantity.ts" />
/// <reference path="Steppable.ts" />
/// <reference path="functions/distSq.ts" />
class PhysicsBody {
    constructor() {
        this.kinematicQuantity = new KinematicQuantity();
        this.mass = 1;
        this.collisionRadius = 0;
        this.hasFriction = false;
        this.decelerationFactor = 1;
    }
    get position() {
        return this.kinematicQuantity.position;
    }
    get x() {
        return this.kinematicQuantity.position.x;
    }
    get y() {
        return this.kinematicQuantity.position.y;
    }
    get z() {
        return this.kinematicQuantity.position.z;
    }
    get velocity() {
        return this.kinematicQuantity.velocity;
    }
    get vx() {
        return this.kinematicQuantity.velocity.x;
    }
    get vy() {
        return this.kinematicQuantity.velocity.y;
    }
    get vz() {
        return this.kinematicQuantity.velocity.z;
    }
    getSpeed() {
        return this.kinematicQuantity.getSpeed();
    }
    getDirection() {
        return this.kinematicQuantity.getDirection();
    }
    setFriction(constant) {
        if (constant === 0) {
            this.hasFriction = false;
            return;
        }
        this.hasFriction = true;
        this.decelerationFactor = 1 - constant;
    }
    constrainSpeed(maxSpeed) {
        if (this.velocity.magSq() > sq(maxSpeed))
            this.velocity.setMag(maxSpeed);
    }
    step() {
        this.kinematicQuantity.step();
        if (this.hasFriction) {
            this.kinematicQuantity.velocity.mult(this.decelerationFactor);
        }
    }
    accelerate(x, y, z) {
        this.kinematicQuantity.velocity.add(x, y, z);
    }
    applyForce(force) {
        this.accelerate(force.x / this.mass, force.y / this.mass, force.z / this.mass);
    }
    addSpeed(speedChange) {
        this.kinematicQuantity.addSpeed(speedChange);
    }
    collides(other) {
        return (distSq(this.position, other.position) < sq(this.collisionRadius) + sq(other.collisionRadius));
    }
    bounce(normalUnitVector, restitution = 1) {
        this.velocity.add(p5.Vector.mult(normalUnitVector, (1 + restitution) * p5.Vector.dot(this.velocity, p5.Vector.mult(normalUnitVector, -1))));
    }
    /**
     * Applies attraction force to both this and the target body.
     * @param {PhysicsBody} other - the other body to interact with
     * @param {number} magnitudeFactor - the factor of magnitude other than the distance
     * @param {number} minMag - the minimum magnitude
     * @param {number} maxMag - the maximum magnitude
     * @param {number} cutoffMag - does not apply force if magnitude is smaller than this
     */
    attractEachOther(other, magnitudeFactor, minMag = 0, maxMag, cutoffMag) {
        const force = this.calculateAttractionForce(other.position, magnitudeFactor, minMag, maxMag, cutoffMag);
        if (!force)
            return;
        this.applyForce(force);
        force.mult(-1);
        other.applyForce(force);
    }
    /**
     * Applies attraction force to both this body.
     * @param {p5.Vector} targetPosition - the target position
     * @param {number} magnitudeFactor - the factor of magnitude other than the distance
     * @param {number} minMag - the minimum magnitude
     * @param {number} maxMag - the maximum magnitude
     * @param {number} cutoffMag - does not apply force if magnitude is smaller than this
     */
    attractToPoint(targetPosition, magnitudeFactor, minMag = 0, maxMag, cutoffMag) {
        const force = this.calculateAttractionForce(targetPosition, magnitudeFactor, minMag, maxMag, cutoffMag);
        if (!force)
            return;
        this.applyForce(force);
    }
    calculateAttractionForce(targetPosition, magnitudeFactor, minMag = 0, maxMag, cutoffMag) {
        const tmpVec = PhysicsBody.temporalVector;
        p5.Vector.sub(targetPosition, this.position, tmpVec); // set relative position
        const distanceSquared = tmpVec.magSq();
        let magnitude = Math.abs(magnitudeFactor) / distanceSquared;
        if (cutoffMag && magnitude < cutoffMag)
            return null;
        if (maxMag)
            magnitude = constrain(magnitude, minMag, maxMag);
        else
            magnitude = Math.max(magnitude, minMag);
        tmpVec.setMag(magnitude); // set force
        if (magnitudeFactor < 0)
            tmpVec.mult(-1);
        return tmpVec;
    }
}
PhysicsBody.temporalVector = createVector();
//
// ------------ Rectangle area -----------------------------
//
/// <reference path="PhysicsBody.ts" />
class RectangleArea {
    constructor(x1, y1, x2, y2) {
        this.leftPositionX = x1;
        this.topPositionY = y1;
        this.rightPositionX = x2;
        this.bottomPositionY = y2;
    }
    keepIn(body, restitution = 1) {
        const bodyRadius = body.collisionRadius;
        if (body.x < this.leftPositionX + bodyRadius) {
            body.position.x = this.leftPositionX + bodyRadius;
            body.velocity.x = -restitution * body.velocity.x;
        }
        else if (body.x > this.rightPositionX - bodyRadius) {
            body.position.x = this.rightPositionX - bodyRadius;
            body.velocity.x = -restitution * body.velocity.x;
        }
        if (body.y < this.topPositionY + bodyRadius) {
            body.position.y = this.topPositionY + bodyRadius;
            body.velocity.y = -restitution * body.velocity.y;
        }
        else if (body.y > this.bottomPositionY - bodyRadius) {
            body.position.y = this.bottomPositionY - bodyRadius;
            body.velocity.y = -restitution * body.velocity.y;
        }
    }
    loopAtEnd(body) {
        if (body.x < this.leftPositionX) {
            body.position.x = this.rightPositionX;
        }
        else if (body.x > this.rightPositionX) {
            body.position.x = this.leftPositionX;
        }
        if (body.y < this.topPositionY) {
            body.position.y = this.bottomPositionY;
        }
        else if (body.y > this.bottomPositionY) {
            body.position.y = this.topPositionY;
        }
    }
}
//
// ------------ hsbColor() -----------------------------
//
/// <reference path="../../../../my_types/p5/p5.global-mode.d.ts" />
function hsbColor(h, s, b, a = 255) {
    colorMode(HSB, 360, 100, 100, 255);
    const c = color(h, s, b);
    colorMode(RGB);
    return c;
}
//
// ------------ randomInt() -----------------------------
//
/**
 * Returns random integer from 0 up to (but not including) the max number.
 */
function randomInt(maxInt) {
    return Math.floor(Math.random() * maxInt);
}
/**
 * Returns random integer from the min number up to (but not including) the max number.
 */
function randomIntBetween(minInt, maxInt) {
    return minInt + randomInt(maxInt - minInt);
}
//
// ------------ getRandom() -------------------------------------
//
/// <reference path="randomInt.ts" />
function getRandom(array) {
    return array[randomInt(array.length)];
}
//
// ------------ popRandom() -------------------------------------
//
/// <reference path="randomInt.ts" />
function popRandom(array) {
    return array.splice(randomInt(array.length), 1)[0]; // bug fixed 2017-11-22
}
//
// ---------- getRandomSubset() --------------------------------------------
//
/// <reference path="../../../../my_types/p5/p5.global-mode.d.ts" />
/// <reference path="popRandom.ts" />
function getRandomSubset(srcArray, count) {
    const subset = [];
    const candidates = [];
    arrayCopy(srcArray, candidates);
    for (let i = 0; i < count && candidates.length > 0; i += 1) {
        subset.push(popRandom(candidates));
    }
    return subset;
}
//
// ------------ calculateLeverageForce() -----------------------------
//
/// <reference path="../../../../my_types/p5/p5.global-mode.d.ts" />
/**
 * Returns the 2D force vector which is to be applied to the load.
 * @param loadDirectionAngle - the direction angle from the fulcrum to the load
 * @param loadDistance - the distance between the fulcrum and the load
 * @param effortDistance - the distance between the fulcrum and the effort
 * @param effortForceMagnitude - the effort force magnitude
 * @param rotateClockwise - true if the load is to be rotated clockwise, otherwise false
 * @param target - the vector to receive the result. Will be newly created if not specified
 */
function calculateLeverageForce(loadDirectionAngle, loadDistance, effortDistance, effortForceMagnitude, rotateClockwise, target) {
    const force = target || createVector();
    const forceDirectionAngle = loadDirectionAngle + (rotateClockwise ? -HALF_PI : HALF_PI);
    force.set(cos(forceDirectionAngle), sin(forceDirectionAngle));
    force.setMag(effortForceMagnitude * effortDistance / loadDistance); // load force
    return force;
}
//
// ------------ Edge -----------------------------
//
class NaiveEdge {
    constructor(nodeA, nodeB) {
        this.nodeA = nodeA;
        this.nodeB = nodeB;
    }
    isIncidentTo(node) {
        return node === this.nodeA || node === this.nodeB;
    }
    /**
     * Returns the adjacent node of the given node via this edge.
     * If this edge is not incident to the given node, returns alwayes the end point node.
     * @param {T} node - any node which is incident to this edge
     */
    getAdjacentNode(node) {
        if (node === this.nodeB)
            return this.nodeA;
        return this.nodeB;
    }
}
/// <reference path="Edge.ts" />
//
// ------------ Cross-reference array-graph -------------------------------------
//
/// <reference path="Graph.ts" />
/// <reference path="ArrayWrapper.ts" />
class CrossReferenceArrayGraph {
    constructor(createNodeArrayFunction, createEdgeArrayFunction) {
        this.nodes = createNodeArrayFunction();
        this.edges = createEdgeArrayFunction();
        this.incidentEdgesMap = new Map();
        this.createEdgeArrayFunction = createEdgeArrayFunction;
    }
    getIncidentEdges(node) {
        return this.incidentEdgesMap.get(node);
    }
    addNode(node) {
        this.nodes.push(node);
        this.incidentEdgesMap.set(node, this.createEdgeArrayFunction());
    }
    addEdge(edge) {
        this.edges.push(edge);
        const incidentEdgesOfA = this.incidentEdgesMap.get(edge.nodeA);
        if (incidentEdgesOfA)
            incidentEdgesOfA.push(edge);
        const incidentEdgesOfB = this.incidentEdgesMap.get(edge.nodeB);
        if (incidentEdgesOfB)
            incidentEdgesOfB.push(edge);
    }
}
//
// ------------ Drawable -----------------------------
//
/// <reference path="ArrayWrapper.ts" />
class DrawableArray extends ArrayWrapper {
    static drawFunction(value) {
        value.draw();
    }
    draw() {
        this.loop(DrawableArray.drawFunction);
    }
}
//
// ------------ Sprite -------------------------------------
//
/// <reference path="ArrayWrapper.ts" />
/// <reference path="Steppable.ts" />
/// <reference path="Drawable.ts" />
class SpriteArray extends ArrayWrapper {
    constructor() {
        super(...arguments);
        this.draw = DrawableArray.prototype.draw;
        this.step = SteppableArray.prototype.step;
    }
}
//
// ------------ Cleanable -----------------------------
//
/// <reference path="ArrayWrapper.ts" />
class CleanableArray extends ArrayWrapper {
    cleanFunction(value, index, array) {
        value.clean();
        if (value.isToBeRemoved) {
            array.splice(index, 1);
        }
    }
    clean() {
        this.loop(this.cleanFunction);
    }
}
//
// ------------ Cleanable Sprite -------------------------------------
//
/// <reference path="Sprite.ts" />
/// <reference path="Cleanable.ts" />
class CleanableSpriteArray extends SpriteArray {
    constructor() {
        super(...arguments);
        this.cleanFunction = CleanableArray.prototype.cleanFunction;
        this.clean = CleanableArray.prototype.clean;
    }
}
//
// ------------ Cleanable sprite cross-reference array-graph -----------------------
//
/// <reference path="CrossReferenceArrayGraph.ts" />
/// <reference path="CleanableSprite.ts" />
class CleanableSpriteCrossReferenceArrayGraph extends CrossReferenceArrayGraph {
    constructor() {
        super(() => { return new CleanableSpriteArray(); }, () => { return new CleanableSpriteArray(); });
        this.cleanMap = (node) => {
            if (node.isToBeRemoved) {
                this.incidentEdgesMap.delete(node);
            }
            else {
                const incidentEdges = this.incidentEdgesMap.get(node);
                if (incidentEdges)
                    incidentEdges.clean();
            }
        };
    }
    step() {
        this.nodes.step();
        this.edges.step();
    }
    clean() {
        this.nodes.clean();
        this.edges.clean();
        this.nodes.loop(this.cleanMap);
    }
    draw() {
        this.edges.draw();
        this.nodes.draw();
    }
}
//
// --------- ShapeColor (Composite of fill & stroke) -------------
//
class AbstractShapeColor {
    static createAlphaColorArray(c) {
        const array = [];
        for (let alphaValue = 0; alphaValue <= 255; alphaValue += 1) {
            array.push(color(red(c), green(c), blue(c), alpha(c) * alphaValue / 255));
        }
        return array;
    }
}
class ShapeColor extends AbstractShapeColor {
    constructor(strokeColor, fillColor) {
        super();
        this.strokeColorArray = AbstractShapeColor.createAlphaColorArray(strokeColor);
        this.fillColorArray = AbstractShapeColor.createAlphaColorArray(fillColor);
    }
    applyColor(alphaValue = 255) {
        const index = Math.floor(constrain(alphaValue, 0, 255));
        stroke(this.strokeColorArray[index]);
        fill(this.fillColorArray[index]);
    }
    applyToGraphics(graphics, alphaValue = 255) {
        const index = Math.floor(constrain(alphaValue, 0, 255));
        graphics.stroke(this.strokeColorArray[index]);
        graphics.fill(this.fillColorArray[index]);
    }
}
class NoStrokeShapeColor extends AbstractShapeColor {
    constructor(fillColor) {
        super();
        this.fillColorArray = AbstractShapeColor.createAlphaColorArray(fillColor);
    }
    applyColor(alphaValue = 255) {
        noStroke();
        const index = Math.floor(constrain(alphaValue, 0, 255));
        fill(this.fillColorArray[index]);
    }
    applyToGraphics(graphics, alphaValue = 255) {
        graphics.noStroke();
        const index = Math.floor(constrain(alphaValue, 0, 255));
        graphics.fill(this.fillColorArray[index]);
    }
}
class NoFillShapeColor extends AbstractShapeColor {
    constructor(strokeColor) {
        super();
        this.strokeColorArray = AbstractShapeColor.createAlphaColorArray(strokeColor);
    }
    applyColor(alphaValue = 255) {
        const index = Math.floor(constrain(alphaValue, 0, 255));
        stroke(this.strokeColorArray[index]);
        noFill();
    }
    applyToGraphics(graphics, alphaValue = 255) {
        const index = Math.floor(constrain(alphaValue, 0, 255));
        graphics.stroke(this.strokeColorArray[index]);
        graphics.noFill();
    }
}
class NullShapeColor extends AbstractShapeColor {
    applyColor() { }
    applyToGraphics() { }
}
//
// ------------ Random shape color -----------------------------
//
/// <reference path="functions/getRandom.ts" />
/// <reference path="ShapeColor.ts" />
class RandomShapeColor {
    constructor(createShapeColor, candidateCount) {
        this.candidateArray = [];
        for (let i = 0; i < candidateCount; i += 1) {
            this.candidateArray.push(createShapeColor());
        }
    }
    get() {
        return getRandom(this.candidateArray);
    }
}
//
// ------------ Angle quantity -----------------------------
//
/// <reference path="Steppable.ts" />
class AngleQuantity {
    constructor(angle = 0, angleVelocity = 0) {
        this.angle = angle;
        this.angleVelocity = angleVelocity;
    }
    step() {
        this.angle += this.angleVelocity;
    }
}
//
// ------------ ScaleFactor -----------------------------
//
class ScaleFactor {
    constructor(value = 1) {
        this.internalValue = value;
        this.internalReciprocalValue = 1 / value;
    }
    get value() {
        return this.internalValue;
    }
    set value(v) {
        if (v === 0) {
            this.internalValue = 0.0001;
            this.internalReciprocalValue = 10000;
            return;
        }
        this.internalValue = v;
        this.internalReciprocalValue = 1 / v;
    }
    get reciprocalValue() {
        return this.internalValue;
    }
    applyScale() {
        scale(this.internalValue);
    }
    cancel() {
        scale(this.internalReciprocalValue);
    }
}
//
// ------------ Frame counter -----------------------------
//
/// <reference path="global/commonGlobalSettings.ts" />
/// <reference path="Steppable.ts" />
class FrameCounter {
    constructor() {
        this.count = 0;
    }
    resetCount(count = 0) {
        this.count = count;
    }
    step() {
        this.count += 1;
    }
    mod(divisor) {
        return this.count % divisor;
    }
    /**
     * Returns ratio from 0 to 1 according to current frame count and given frequency per second.
     * @param frequency {number} - frequency per second
     */
    getCycleProgressRatio(frequency) {
        return ((frequency * this.count) % IDEAL_FRAME_RATE) / IDEAL_FRAME_RATE;
    }
    /**
     * Returns sine value (from 0 to 1)according to
     * current frame count and given frequency per second.
     * @param frequency {number} - frequency per second
     */
    sin(frequency) {
        return Math.sin(this.getCycleProgressRatio(frequency) * 2 * Math.PI);
    }
}
//
// ------------ Timed frame counter -----------------------------
//
/// <reference path="FrameCounter.ts" />
class TimedFrameCounter extends FrameCounter {
    constructor(on, duration = 0, completeBehavior = () => { }) {
        super();
        this.isOn = on;
        this.isCompleted = false;
        this.completeBehavior = completeBehavior;
        this.durationFrameCount = duration;
    }
    on(duration) {
        this.isOn = true;
        if (duration)
            this.durationFrameCount = duration;
    }
    off() {
        this.isOn = false;
    }
    step() {
        if (!this.isOn)
            return;
        this.count += 1;
        if (this.count > this.durationFrameCount) {
            this.isCompleted = true;
            this.isOn = false;
            this.completeBehavior();
        }
    }
    getProgressRatio() {
        if (this.durationFrameCount) {
            return Math.min(Math.max(this.count / this.durationFrameCount, 0), 1);
        }
        else
            return 0;
    }
}
//
// ------------ randomSign() -----------------------------
//
function randomSign(n) {
    if (Math.random() < 0.5)
        return n;
    else
        return -n;
}
//
// ------------ angleDifference() -----------------------------
//
/// <reference path="../../../../my_types/p5/p5.global-mode.d.ts" />
/**
 * Calculates the difference between two angles in range of -PI to PI.
 * @param angleA - the angle to subtract from
 * @param angleB - the angle to subtract
 */
function angleDifference(angleA, angleB) {
    let diff = (angleA - angleB) % (TWO_PI);
    if (diff < -PI)
        diff += TWO_PI;
    else if (diff > PI)
        diff -= TWO_PI;
    return diff;
}
//
// ------------ Drawer -----------------------------
//
/// <reference path="../../../my_types/p5/p5.global-mode.d.ts" />
/// <reference path="Drawable.ts" />
/// <reference path="AngleQuantity.ts" />
/// <reference path="ScaleFactor.ts" />
/// <reference path="ShapeColor.ts" />
class Drawer {
    constructor(element, drawParam) {
        this.element = element;
        this.position = drawParam.position || createVector();
        this.rotation = drawParam.rotation || new AngleQuantity();
        this.scaleFactor = drawParam.scaleFactor || new ScaleFactor();
        this.shapeColor = drawParam.shapeColor || new NullShapeColor();
        this.procedureList = this.createProcedureList(drawParam);
    }
    draw() {
        for (let i = 0, len = this.procedureList.length; i < len; i += 1) {
            this.procedureList[i](this);
        }
    }
    createProcedureList(drawParam) {
        const procedureList = [];
        if (drawParam.shapeColor) {
            procedureList.push(this.color);
        }
        if (drawParam.position) {
            procedureList.push(this.translate);
        }
        if (drawParam.scaleFactor) {
            procedureList.push(this.scale);
        }
        if (drawParam.rotation) {
            procedureList.push(this.rotate);
        }
        procedureList.push(this.drawElement);
        if (drawParam.rotation) {
            procedureList.push(this.cancelRotate);
        }
        if (drawParam.scaleFactor) {
            procedureList.push(this.cancelScale);
        }
        if (drawParam.position) {
            procedureList.push(this.cancelTranslate);
        }
        return procedureList;
    }
    drawElement(drawer) {
        drawer.element.draw();
    }
    translate(drawer) {
        translate(drawer.position.x, drawer.position.y);
    }
    cancelTranslate(drawer) {
        translate(-drawer.position.x, -drawer.position.y);
    }
    rotate(drawer) {
        rotate(drawer.rotation.angle);
    }
    cancelRotate(drawer) {
        rotate(-drawer.rotation.angle);
    }
    scale(drawer) {
        if (drawer.scaleFactor.value === 1)
            return;
        drawer.scaleFactor.applyScale();
    }
    cancelScale(drawer) {
        if (drawer.scaleFactor.value === 1)
            return;
        drawer.scaleFactor.cancel();
    }
    color(drawer) {
        drawer.shapeColor.applyColor();
    }
}
//
// ------------ Organic node -----------------------------
//
/// <reference path="../../my_types/p5/p5.global-mode.d.ts" />
/// <reference path="common/global/commonGlobalSettings.ts" />
/// <reference path="common/PhysicsBody.ts" />
/// <reference path="common/AngleQuantity.ts" />
/// <reference path="common/Sprite.ts" />
/// <reference path="common/ScaleFactor.ts" />
/// <reference path="common/TimedFrameCounter.ts" />
/// <reference path="common/functions/randomSign.ts" />
/// <reference path="common/functions/angleDifference.ts" />
/// <reference path="common/Drawer.ts" />
class OrganicNode extends PhysicsBody {
    constructor(shapeSize) {
        super();
        this.isToBeRemoved = false;
        this.shapeSize = shapeSize;
        this.componentScaleFactor = new ScaleFactor();
        this.rotation = new AngleQuantity(random(TWO_PI), randomSign(random(0.02, 0.05) * UNIT_ANGLE_SPEED)),
            this.scaleFactor = new ScaleFactor();
        this.componentArray = new SpriteArray();
        this.drawer = new Drawer(this.componentArray, {
            position: this.position,
            rotation: this.rotation,
            scaleFactor: this.scaleFactor,
        });
        // Closure functions for frame counters
        this.resetScaleFactor = () => {
            this.scaleFactor.value = 1;
            this.componentScaleFactor.value = 1;
        };
        this.remove = () => {
            this.isToBeRemoved = true;
        };
        // Frame counters. Must be after declaring resetScaleFactor() and remove().
        this.appearanceCounter = new TimedFrameCounter(true, 0.5 * IDEAL_FRAME_RATE, this.resetScaleFactor);
        this.disappearanceCounter = new TimedFrameCounter(false, 0.5 * IDEAL_FRAME_RATE, this.remove);
        this.blinkCounter = new TimedFrameCounter(false, OrganicNode.blinkDurationSecond * IDEAL_FRAME_RATE, this.resetScaleFactor);
        // Properties of PhysicsBody
        this.collisionRadius = 0.5 * shapeSize;
        this.setFriction(0.05);
    }
    step() {
        super.step();
        this.rotation.step();
        this.componentArray.step();
        this.appearanceCounter.step();
        this.disappearanceCounter.step();
        this.blinkCounter.step();
        this.checkFrameCounters();
    }
    clean() {
    }
    draw() {
        this.drawer.draw();
    }
    beginDisappear() {
        this.disappearanceCounter.on();
    }
    addComponent(sprite, col, pos) {
        const component = new SpriteDrawer(sprite, {
            position: pos,
            scaleFactor: this.componentScaleFactor,
            shapeColor: col,
        });
        this.componentArray.push(component);
    }
    checkFrameCounters() {
        if (this.appearanceCounter.isOn) {
            this.componentScaleFactor.value = this.appearanceCounter.getProgressRatio();
            return;
        }
        if (this.disappearanceCounter.isOn) {
            this.componentScaleFactor.value = 1 - this.disappearanceCounter.getProgressRatio();
            return;
        }
        if (this.blinkCounter.isOn) {
            this.scaleFactor.value
                = 1 - 0.75 * this.blinkCounter.sin(1 / (2 * OrganicNode.blinkDurationSecond));
        }
        else {
            if (Math.random() < OrganicNode.blinkProbability) {
                this.blinkCounter.resetCount();
                this.blinkCounter.on();
            }
            return;
        }
    }
}
OrganicNode.blinkProbability = 0.002;
OrganicNode.blinkDurationSecond = 0.5;
//
// ------------ Noise shape ------------------------------
//
/// <reference path="../../../my_types/p5/p5.global-mode.d.ts" />
/// <reference path="global/commonGlobalSettings.ts" />
/// <reference path="Sprite.ts" />
class NoiseShape {
    constructor(params) {
        this.offsetPosition = createVector();
        this.shapeSize = params.shapeSize;
        this.noiseMagnitudeFactor = params.noiseMagnitudeFactor;
        this.vertexCount
            = Math.max(6, Math.round(canvasScaleFactor * (params.vertexCount || 0.2 * params.shapeSize)));
        this.noiseDistanceScale = params.noiseDistanceScale || params.shapeSize / 320;
        this.noiseTimeScale = params.noiseTimeScale || 0.005;
        this.xNoiseParameterOffset
            = createVector(Math.random(), Math.random(), Math.random()).mult(1024);
        this.yNoiseParameterOffset
            = createVector(Math.random(), Math.random(), Math.random()).mult(1024);
        this.curveVertexIndexArray = [];
        for (let i = 0; i < this.vertexCount; i += 1) {
            this.curveVertexIndexArray.push(i);
        }
        this.curveVertexIndexArray.push(0, 1, 2);
        this.vertexPositionArray = [];
        for (let i = 0; i < this.vertexCount; i += 1) {
            this.vertexPositionArray.push(createVector());
        }
        this.noiseTime = 0;
    }
    step() {
        this.updateVerticesPosition();
        this.noiseTime += this.noiseTimeScale;
    }
    draw() {
        beginShape();
        for (let i = 0, len = this.curveVertexIndexArray.length; i < len; i += 1) {
            curveVertex(this.vertexPositionArray[this.curveVertexIndexArray[i]].x, this.vertexPositionArray[this.curveVertexIndexArray[i]].y);
        }
        endShape();
    }
    updateVerticesPosition() {
        const baseDistance = 0.5 * this.shapeSize;
        const noiseMagnitude = this.noiseMagnitudeFactor * baseDistance;
        for (let i = 0; i < this.vertexCount; i += 1) {
            const vertexAngle = (i / this.vertexCount) * TWO_PI;
            const cosine = cos(vertexAngle);
            const sine = sin(vertexAngle);
            const baseX = baseDistance * cosine;
            const baseY = baseDistance * sine;
            const noiseX = (2 * noise(this.xNoiseParameterOffset.x + this.noiseDistanceScale * cosine, this.xNoiseParameterOffset.y + this.noiseDistanceScale * sine, this.xNoiseParameterOffset.z + this.noiseTime) - 1) * noiseMagnitude;
            const noiseY = (2 * noise(this.yNoiseParameterOffset.x + this.noiseDistanceScale * cosine, this.yNoiseParameterOffset.y + this.noiseDistanceScale * sine, this.yNoiseParameterOffset.z + this.noiseTime) - 1) * noiseMagnitude;
            this.vertexPositionArray[i].set(this.offsetPosition.x + baseX + noiseX, this.offsetPosition.y + baseY + noiseY);
        }
    }
}
//
// ------------ Simple node -----------------------------
//
/// <reference path="../../my_types/p5/p5.global-mode.d.ts" />
/// <reference path="OrganicNode.ts" />
/// <reference path="common/NoiseShape.ts" />
/// <reference path="common/RandomShapeColor.ts" />
class SimpleNode extends OrganicNode {
    constructor(shapeSize, randomShapeColor) {
        super(shapeSize);
        const noiseShape = new NoiseShape({
            shapeSize: this.shapeSize,
            noiseMagnitudeFactor: 1,
            noiseDistanceScale: this.shapeSize / 200,
            noiseTimeScale: 0.02,
        });
        this.addComponent(noiseShape, randomShapeColor.get());
    }
}
//
// ------------ Bubble node -----------------------------
//
/// <reference path="../../my_types/p5/p5.global-mode.d.ts" />
/// <reference path="OrganicNode.ts" />
/// <reference path="common/NoiseShape.ts" />
/// <reference path="common/RandomShapeColor.ts" />
class BubbleNode extends OrganicNode {
    constructor(bubbleSize, componentShapeSize, randomShapeColor) {
        super(bubbleSize);
        const componentCount = 2 * Math.floor(bubbleSize / componentShapeSize);
        const radius = 0.5 * bubbleSize;
        for (let i = 0; i < componentCount; i += 1) {
            const angle = (i / componentCount) * TWO_PI;
            const noiseShape = new NoiseShape({
                shapeSize: componentShapeSize,
                noiseMagnitudeFactor: 0.5,
                noiseDistanceScale: componentShapeSize / 30,
                noiseTimeScale: 0.07,
            });
            this.addComponent(noiseShape, randomShapeColor.get(), createVector(radius * cos(angle), radius * sin(angle)));
        }
    }
}
//
// ------------ Noise polygon ------------------------------
//
/// <reference path="../../../my_types/p5/p5.global-mode.d.ts" />
/// <reference path="Sprite.ts" />
class NoisePolygon {
    constructor(params) {
        this.noiseMagnitude = params.noiseMagnitude;
        this.noiseTimeScale = params.noiseTimeScale || 0.005;
        this.vertexPositionArray = params.vertexPositionArray;
        this.noiseTimeOffsetArray = [];
        for (let i = 0, len = params.vertexPositionArray.length; i < len; i += 1) {
            this.noiseTimeOffsetArray.push(createVector(Math.random(), Math.random()).mult(1024));
        }
        this.noiseTime = 0;
    }
    step() {
        this.noiseTime += this.noiseTimeScale;
    }
    draw() {
        beginShape();
        for (let i = 0, len = this.vertexPositionArray.length; i < len; i += 1) {
            const noiseX = (2 * noise(this.noiseTimeOffsetArray[i].x + this.noiseTime) - 1) * this.noiseMagnitude;
            const noiseY = (2 * noise(this.noiseTimeOffsetArray[i].y + this.noiseTime) - 1) * this.noiseMagnitude;
            vertex(this.vertexPositionArray[i].x + noiseX, this.vertexPositionArray[i].y + noiseY);
        }
        endShape(CLOSE);
    }
}
//
// ------------ Leaves node -----------------------------
//
/// <reference path="../../my_types/p5/p5.global-mode.d.ts" />
/// <reference path="OrganicNode.ts" />
/// <reference path="common/NoisePolygon.ts" />
/// <reference path="common/RandomShapeColor.ts" />
class LeavesNode extends OrganicNode {
    constructor(shapeSize, componentCount, randomShapeColor) {
        super(shapeSize);
        const radius = 0.6 * shapeSize;
        for (let i = 0; i < componentCount; i += 1) {
            const angle = (i / componentCount) * TWO_PI;
            const vertices = [
                createVector(0, -1).mult(radius).rotate(angle),
                createVector(0.18, -0.4).mult(radius).rotate(angle),
                createVector(0, -0.1).mult(radius).rotate(angle),
                createVector(-0.18, -0.4).mult(radius).rotate(angle),
            ];
            const noiseShape = new NoisePolygon({
                vertexPositionArray: vertices,
                noiseMagnitude: radius * 0.08,
                noiseTimeScale: 0.05,
            });
            this.addComponent(noiseShape, randomShapeColor.get());
        }
    }
}
//
// ------------ Sprite drawer ------------------------------
//
/// <reference path="../../../my_types/p5/p5.global-mode.d.ts" />
/// <reference path="Drawer.ts" />
/// <reference path="Sprite.ts" />
class SpriteDrawer extends Drawer {
    constructor(shape, params) {
        super(shape, params);
    }
    step() {
        this.element.step();
    }
}
//
// ------------ Physics body edge -----------------------------
//
/// <reference path="../../../my_types/p5/p5.global-mode.d.ts" />
/// <reference path="global/onDemandGlobalMode.ts" />
/// <reference path="functions/distSq.ts" />
/// <reference path="PhysicsBody.ts" />
/// <reference path="Edge.ts" />
/// <reference path="Steppable.ts" />
class PhysicsBodyEdge extends NaiveEdge {
    constructor(nodeA, nodeB) {
        super(nodeA, nodeB);
        this.relativePositionA = createVector();
        this.relativePositionB = createVector();
        this.update();
    }
    step() {
        this.update();
    }
    update() {
        this.relativePositionA.set(this.nodeA.position.x - this.nodeB.position.x, this.nodeA.position.y - this.nodeB.position.y);
        this.relativePositionB.set(this.nodeB.position.x - this.nodeA.position.x, this.nodeB.position.y - this.nodeA.position.y);
        this.directionAngleA = this.relativePositionA.heading();
        this.directionAngleB = this.directionAngleA + PI;
        if (this.directionAngleB > TWO_PI)
            this.directionAngleB -= TWO_PI;
        this.distanceSquared = distSq(this.nodeA.position, this.nodeB.position);
    }
    getRelativePosition(referenceNode) {
        if (referenceNode === this.nodeB)
            return this.relativePositionA;
        return this.relativePositionB;
    }
    getDirectionAngle(referenceNode) {
        if (referenceNode === this.nodeB)
            return this.directionAngleA;
        return this.directionAngleB;
    }
}
//
// ------------ Physics spring -----------------------------
//
/// <reference path="../../../my_types/p5/p5.global-mode.d.ts" />
/// <reference path="global/onDemandGlobalMode.ts" />
/// <reference path="PhysicsBody.ts" />
/// <reference path="PhysicsBodyEdge.ts" />
/// <reference path="Edge.ts" />
class PhysicsSpring extends PhysicsBodyEdge {
    constructor(nodeA, nodeB, equilibriumLength = 100, springConstant = 0.005) {
        super(nodeA, nodeB);
        this.equilibriumLength = equilibriumLength;
        this.springConstant = springConstant;
    }
    step() {
        super.step();
        const bodyA = this.nodeA;
        const bodyB = this.nodeB;
        const stretchLength = sqrt(this.distanceSquared) - this.equilibriumLength;
        const tmpVec = PhysicsSpring.temporalVector;
        tmpVec.set(this.relativePositionB);
        tmpVec.setMag(this.springConstant * stretchLength); // set spring force to be applied to A
        bodyA.applyForce(tmpVec);
        tmpVec.mult(-1); // set spring force to be applied to B
        bodyB.applyForce(tmpVec);
    }
}
PhysicsSpring.temporalVector = createVector();
//
// ------------ Organic edge -----------------------------
//
/// <reference path="../../my_types/p5/p5.global-mode.d.ts" />
/// <reference path="OrganicNode.ts" />
/// <reference path="common/SpriteDrawer.ts" />
/// <reference path="common/PhysicsSpring.ts" />
/// <reference path="common/CleanableSprite.ts" />
/// <reference path="common/NoiseShape.ts" />
/// <reference path="common/ScaleFactor.ts" />
class OrganicEdge extends PhysicsSpring {
    constructor(nodeA, nodeB, equilibriumLength, componentShapeSize, componentCount, getShapeColor = () => { return new NoStrokeShapeColor(0); }) {
        super(nodeA, nodeB, equilibriumLength, 0.001);
        this.isToBeRemoved = false;
        this.componentArray = new SpriteArray();
        this.componentScaleFactor = new ScaleFactor();
        for (let i = 0; i < componentCount; i += 1) {
            const noiseShape = new NoiseShape({
                shapeSize: componentShapeSize,
                noiseMagnitudeFactor: 0.75,
                noiseDistanceScale: componentShapeSize / 30,
                noiseTimeScale: 0.1,
            });
            const component = new SpriteDrawer(noiseShape, {
                position: createVector(),
                scaleFactor: this.componentScaleFactor,
                shapeColor: getShapeColor(),
            });
            this.componentArray.push(component);
        }
    }
    step() {
        super.step();
        this.componentArray.step();
        this.updateComponentsPosition();
        this.updateComponentScaleFactor();
    }
    clean() {
        if (this.nodeA.isToBeRemoved || this.nodeB.isToBeRemoved)
            this.isToBeRemoved = true;
    }
    draw() {
        this.componentArray.draw();
    }
    updateComponentsPosition() {
        const directionVector = OrganicEdge.temporalVectorArray[0];
        const startPosition = OrganicEdge.temporalVectorArray[1];
        const endPosition = OrganicEdge.temporalVectorArray[2];
        // set relative position of B
        p5.Vector.sub(this.nodeB.position, this.nodeA.position, directionVector);
        // set start position
        directionVector.setMag(0.5 * this.nodeA.shapeSize);
        p5.Vector.add(this.nodeA.position, directionVector, startPosition);
        // set end position
        directionVector.setMag(0.5 * this.nodeB.shapeSize);
        p5.Vector.sub(this.nodeB.position, directionVector, endPosition);
        for (let i = 0, len = this.componentArray.length; i < len; i += 1) {
            const ratio = (i + 1) / (len + 1);
            this.componentArray.get(i).position.set(startPosition.x + ratio * (endPosition.x - startPosition.x), startPosition.y + ratio * (endPosition.y - startPosition.y));
        }
    }
    updateComponentScaleFactor() {
        this.componentScaleFactor.value = Math.min(this.nodeA.componentScaleFactor.value, this.nodeB.componentScaleFactor.value);
    }
}
OrganicEdge.temporalVectorArray = [
    p5.Vector.fromAngle(0), p5.Vector.fromAngle(0), p5.Vector.fromAngle(0),
];
//
// ------------ Organic graph -----------------------------
//
/// <reference path="common/global/commonGlobalSettings.ts" />
/// <reference path="common/functions/hsbColor.ts" />
/// <reference path="common/functions/randomInt.ts" />
/// <reference path="common/functions/getRandom.ts" />
/// <reference path="common/functions/getRandomSubset.ts" />
/// <reference path="common/functions/calculateLeverageForce.ts" />
/// <reference path="common/CleanableSpriteCrossReferenceArrayGraph.ts" />
/// <reference path="common/RandomShapeColor.ts" />
/// <reference path="common/RectangleArea.ts" />
/// <reference path="OrganicNode.ts" />
/// <reference path="SimpleNode.ts" />
/// <reference path="BubbleNode.ts" />
/// <reference path="LeavesNode.ts" />
/// <reference path="OrganicEdge.ts" />
class OrganicGraph extends CleanableSpriteCrossReferenceArrayGraph {
    constructor(area, maxNodeCount) {
        super();
        this.area = area;
        this.maxNodeCount = maxNodeCount;
        this.keepInScreen = (body) => {
            this.area.keepIn(body, 0.7);
        };
        this.keepAwayIncidentEdges = (node) => {
            const edges = this.getIncidentEdges(node);
            if (!edges)
                return;
            const edgeCount = edges.length;
            for (let i = 0; i < edgeCount; i += 1) {
                const nextIndex = (i + 1) % edgeCount;
                this.keepAwayEdgePair(node, edges.get(i), edges.get(nextIndex), 0.3);
            }
        };
        this.randomShapeColor = new RandomShapeColor(this.createShapeColor, 100);
        for (let i = 0; i < 7; i += 1) {
            this.increaseNode();
        }
    }
    step() {
        const populationRatio = this.nodes.length / this.maxNodeCount;
        if (Math.random() < 0.01 * (1 - populationRatio))
            this.increaseNode();
        if (Math.random() < 0.02 * (populationRatio))
            this.decreaseNode();
        super.step();
        this.nodes.loop(this.keepInScreen);
        this.nodes.loop(this.keepAwayIncidentEdges);
        this.nodes.roundRobin(this.applyRepulsion);
    }
    applyRepulsion(element, otherElement) {
        // Maybe not correct, but works for now
        element.attractEachOther(otherElement, -10000000 * UNIT_ACCELERATION_MAGNITUDE, 0, 10000 * UNIT_ACCELERATION_MAGNITUDE, 200 * UNIT_ACCELERATION_MAGNITUDE);
    }
    getAveragePosition(nodeArray) {
        return nodeArray.reduce((previousPosition, currentNode) => {
            return previousPosition.add(currentNode.position);
        }, createVector()).div(nodeArray.length);
    }
    createShapeColor() {
        const yellowFactor = Math.random();
        const hueValue = 130 - yellowFactor * 80;
        const saturationValue = 40 + yellowFactor * (0.5 + 0.5 * Math.random()) * 30;
        const brightnessValue = 45 + yellowFactor * (0.7 + 0.3 * Math.random()) * 55;
        return new NoStrokeShapeColor(hsbColor(hueValue, saturationValue, brightnessValue));
    }
    increaseNode() {
        if (this.nodes.length >= maxNodeCount)
            return;
        let newNode;
        switch (randomInt(3)) {
            default:
            case 0:
                newNode = new SimpleNode(random(25, 50), this.randomShapeColor);
                break;
            case 1:
                newNode = new BubbleNode(random(40, 90), random(8, 14), this.randomShapeColor);
                break;
            case 2:
                newNode = new LeavesNode(random(40, 70), randomIntBetween(4, 7), this.randomShapeColor);
                break;
        }
        const nodesToLink = getRandomSubset(this.nodes.array, random([0, 1, 1, 1, 2, 2]));
        if (nodesToLink.length === 0) {
            newNode.position.set(random(0.2, 0.8) * nonScaledWidth, random(0.2, 0.8) * nonScaledHeight);
        }
        else {
            newNode.position.set(this.getAveragePosition(nodesToLink)
                .add(p5.Vector.random2D().mult(random(50, 200))));
        }
        this.addNode(newNode);
        for (const nodeToLink of nodesToLink) {
            const edgeComponentCount = randomIntBetween(2, 7);
            const newEdge = new OrganicEdge(newNode, nodeToLink, 60 * edgeComponentCount, 10, edgeComponentCount, this.createShapeColor);
            this.addEdge(newEdge);
        }
    }
    decreaseNode() {
        const node = getRandom(this.nodes.array);
        if (node.appearanceCounter.isOn)
            return;
        if (node.disappearanceCounter.isOn)
            return;
        if (node.blinkCounter.isOn)
            return;
        node.beginDisappear();
    }
    keepAwayEdgePair(node, edgeA, edgeB, magnitudeFactor) {
        const directionAngleA = edgeA.getDirectionAngle(node);
        const directionAngleB = edgeB.getDirectionAngle(node);
        const angleDifferenceAB = angleDifference(directionAngleB, directionAngleA);
        const angleDifferenceRatio = abs(angleDifferenceAB) / PI;
        const effortForceMagnitude = magnitudeFactor / sq(Math.max(angleDifferenceRatio, 0.05));
        const tmpVec = OrganicNode.temporalVector;
        const aIsLeft = angleDifferenceAB > 0;
        const forceA = calculateLeverageForce(directionAngleA, sqrt(edgeA.distanceSquared), 1, effortForceMagnitude, aIsLeft, tmpVec);
        edgeA.getAdjacentNode(node).applyForce(forceA);
        const forceB = calculateLeverageForce(directionAngleB, sqrt(edgeB.distanceSquared), 1, effortForceMagnitude, !aIsLeft, tmpVec);
        edgeB.getAdjacentNode(node).applyForce(forceB);
    }
}
//
// ------------ Main -------------------------------------------------------------------------
//
/// <reference path="common/global/commonGlobalSettings.ts" />
/// <reference path="common/RectangleArea.ts" />
/// <reference path="OrganicGraph.ts" />
//
// ---- global variables
let network;
let backgroundColor;
let area;
let maxNodeCount;
// ---- Setup & Draw etc.
function reset() {
    network = new OrganicGraph(area, maxNodeCount);
}
function setup() {
    createCanvas(windowWidth, windowHeight);
    updateCanvasScale();
    frameRate(IDEAL_FRAME_RATE);
    backgroundColor = color(0);
    maxNodeCount = 24 * Math.max(width, height) / Math.min(width, height);
    const margin = 50;
    area = new RectangleArea(margin, margin, nonScaledWidth - margin, nonScaledHeight - margin);
    reset();
}
function draw() {
    scale(canvasScaleFactor);
    background(backgroundColor);
    network.step();
    network.clean();
    network.draw();
}
function mousePressed() {
    network.increaseNode();
}
function keyPressed() {
    if (keyCode === 80)
        noLoop(); // 80: 'P'
}
function keyReleased() {
    if (keyCode === 80)
        loop(); // 80: 'P'
}